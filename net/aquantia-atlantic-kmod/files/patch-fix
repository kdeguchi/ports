From 50e33dda63797cf7838f98b83107f9d8d8ad76d5 Mon Sep 17 00:00:00 2001
From: Yuri Pankov <yuri@aetern.org>
Date: Mon, 5 Aug 2024 14:47:09 +0700
Subject: [PATCH] Quick dirty fix

---
 aq.h        | 674 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 aq_common.h |  87 -------
 aq_dbg.c    |   4 +-
 aq_device.h | 150 ------------
 aq_fw.c     |   6 +-
 aq_fw.h     |  76 ------
 aq_fw1x.c   |   4 +-
 aq_fw2x.c   |   6 +-
 aq_hw.c     |   4 +-
 aq_hw.h     | 356 ---------------------------
 aq_hw_llh.c |   2 +-
 aq_hw_llh.h |   2 +-
 aq_irq.c    |   5 +-
 aq_main.c   |  12 +-
 aq_media.c  |   4 +-
 aq_ring.c   |   8 +-
 aq_ring.h   | 184 --------------
 17 files changed, 690 insertions(+), 894 deletions(-)
 create mode 100644 aq.h
 delete mode 100644 aq_common.h
 delete mode 100644 aq_device.h
 delete mode 100644 aq_fw.h
 delete mode 100644 aq_hw.h
 delete mode 100644 aq_ring.h

diff --git aq.h aq.h
new file mode 100644
index 0000000..2a1990f
--- /dev/null
+++ aq.h
@@ -0,0 +1,674 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   (1) Redistributions of source code must retain the above
+ *   copyright notice, this list of conditions and the following
+ *   disclaimer.
+ *
+ *   (2) Redistributions in binary form must reproduce the above
+ *   copyright notice, this list of conditions and the following
+ *   disclaimer in the documentation and/or other materials provided
+ *   with the distribution.
+ *
+ *   (3)The name of the author may not be used to endorse or promote
+ *   products derived from this software without specific prior
+ *   written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _AQ_H_
+#define _AQ_H_
+
+#include <sys/param.h>
+#include <sys/bitstring.h>
+#include <sys/bus.h>
+#include <sys/cdefs.h>
+#include <sys/endian.h>
+#include <sys/kernel.h>
+#include <sys/socket.h>
+
+#include <machine/cpufunc.h>
+
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+#include <net/if_var.h>
+#include <net/iflib.h>
+
+#include <netinet/in.h>
+
+#define ETH_MAC_LEN 6
+
+#define s8       __int8_t
+#define u8       __uint8_t
+#define u16      __uint16_t
+#define s16      __int16_t
+#define u32      __uint32_t
+#define u64      __uint64_t
+#define s64      __int64_t
+#define s32      int
+
+#define ETIME ETIMEDOUT
+#define	EOK 0
+
+#define BIT(nr) (1UL << (nr))
+
+#define usec_delay(x) DELAY(x)
+
+#ifndef msec_delay
+#define msec_delay(x) DELAY(x*1000)
+#define msec_delay_irq(x) DELAY(x*1000)
+#endif
+
+#define AQ_HW_WAIT_FOR(_B_, _US_, _N_) \
+	do { \
+		unsigned int i; \
+		for (i = _N_; (!(_B_)) && i; --i) { \
+			usec_delay(_US_); \
+		} \
+		if (i == 0) { \
+			err = -1; \
+		} \
+	} while (0)
+
+
+#define LODWORD(a) ((DWORD)(a))
+#define LOWORD(a) ((uint16_t)(a))
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define AQ_VER        "0.0.5"
+
+#define	AQ_WRITE_REG(hw, reg, value) \
+	writel(((hw)->hw_addr + (reg)), htole32(value))
+#define	AQ_READ_REG(hw, reg) \
+	le32toh(readl((hw)->hw_addr + reg))
+
+#define	AQ_WRITE_REG_BIT(hw, reg, msk, shift, value) \
+	do { \
+		if (msk ^ ~0) { \
+			uint32_t reg_old, reg_new = 0; \
+			reg_old = AQ_READ_REG(hw, reg); \
+			reg_new = (reg_old & (~msk)) | (value << shift); \
+			if (reg_old != reg_new) \
+				AQ_WRITE_REG(hw, reg, reg_new); \
+		} else { \
+			AQ_WRITE_REG(hw, reg, value); \
+		} \
+	} while(0);
+
+
+#define	AQ_READ_REG_BIT(a, reg, msk, shift) \
+	((AQ_READ_REG(a, reg) & msk) >> shift)
+
+#define AQ_HW_FLUSH() { (void)AQ_READ_REG(hw, 0x10); }
+
+#define aq_hw_write_reg_bit AQ_WRITE_REG_BIT
+
+#define aq_hw_write_reg AQ_WRITE_REG
+
+/* Statistics  */
+typedef struct aq_hw_stats_s {
+	uint32_t	uprc;
+	uint32_t	mprc;
+	uint32_t	bprc;
+	uint32_t	erpt;
+	uint32_t	uptc;
+	uint32_t	mptc;
+	uint32_t	bptc;
+	uint32_t	erpr;
+	uint32_t	mbtc;
+	uint32_t	bbtc;
+	uint32_t	mbrc;
+	uint32_t	bbrc;
+	uint32_t	ubrc;
+	uint32_t	ubtc;
+	uint32_t	ptc;
+	uint32_t	prc;
+	uint32_t	dpc;
+	uint32_t	cprc;
+} __packed aq_hw_stats_t;
+
+union ip_addr {
+	struct {
+		uint8_t addr[16];
+	} v6;
+	struct {
+		uint8_t padding[12];
+		uint8_t addr[4];
+	} v4;
+} __packed;
+
+typedef struct aq_hw_fw_mbox {
+	uint32_t	version;
+	uint32_t	transaction_id;
+	int		error;
+	aq_hw_stats_t	stats;
+} __packed aq_hw_fw_mbox_t;
+
+typedef struct {
+	union {
+		struct {
+			uint16_t	build_number;
+			uint8_t		minor_version;
+			uint8_t		major_version;
+		};
+		uint32_t	raw;
+	};
+} aq_hw_fw_version;
+
+typedef enum {
+	aq_irq_invalid = 0,
+	aq_irq_legacy,
+	aq_irq_msi,
+	aq_irq_msix,
+} aq_hw_irq_type_t;
+
+typedef struct aq_hw_fc_info {
+	bool		fc_rx;
+	bool		fc_tx;
+} aq_hw_fc_info_t;
+
+enum aq_hw_fw_mpi_state_e {
+	MPI_DEINIT = 0,
+	MPI_RESET = 1,
+	MPI_INIT = 2,
+	MPI_POWER = 4,
+};
+
+typedef enum {
+	aq_fw_none = 0,
+	aq_fw_100M = 1 << 0,
+	aq_fw_1G = 1 << 1,
+	aq_fw_2G5 = 1 << 2,
+	aq_fw_5G = 1 << 3,
+	aq_fw_10G = 1 << 4,
+} aq_fw_link_speed_t;
+
+typedef enum {
+    aq_fw_fc_none  = 0,
+    aq_fw_fc_ENABLE_RX = BIT(0),
+    aq_fw_fc_ENABLE_TX = BIT(1),
+    aq_fw_fc_ENABLE_ALL = aq_fw_fc_ENABLE_RX | aq_fw_fc_ENABLE_TX,
+} aq_fw_link_fc_t;
+
+#define aq_hw_s aq_hw
+typedef struct aq_hw aq_hw_t;
+
+typedef struct aq_firmware_ops {
+	int (*reset)(aq_hw_t *hw);
+
+	int (*set_mode)(aq_hw_t *hw, enum aq_hw_fw_mpi_state_e mode,
+	    aq_fw_link_speed_t speed);
+	int (*get_mode)(aq_hw_t *hw, enum aq_hw_fw_mpi_state_e *mode,
+	    aq_fw_link_speed_t *speed, aq_fw_link_fc_t *fc);
+
+	int (*get_mac_addr)(aq_hw_t *hw, uint8_t *mac_addr);
+	int (*get_stats)(aq_hw_t *hw, aq_hw_stats_t *stats);
+
+	int (*led_control)(struct aq_hw *hal, uint32_t mode);
+} aq_fw_ops_t;
+
+struct aq_hw {
+	void		*aq_dev;
+	uint8_t		*hw_addr;
+	uint32_t	regs_size;
+
+	uint8_t		mac_addr[ETH_MAC_LEN];
+
+	aq_hw_irq_type_t irq_type;
+
+	aq_hw_fc_info_t	fc;
+	uint16_t	link_rate;
+
+	uint16_t	device_id;
+	uint16_t	subsystem_vendor_id;
+	uint16_t	subsystem_device_id;
+	uint16_t	vendor_id;
+	uint8_t		revision_id;
+
+	/* Interrupt Moderation value */
+	int		itr;
+
+	/* Firmware-related stuff */
+	aq_hw_fw_version fw_version;
+	aq_fw_ops_t	*fw_ops;
+	bool		rbl_enabled;
+	bool		fast_start_enabled;
+	bool		flash_present;
+	uint32_t	chip_features;
+	uint64_t	fw_caps;
+
+	bool		lro_enabled;
+
+	uint32_t	mbox_addr;
+	aq_hw_fw_mbox_t	mbox;
+};
+
+#define AQ_HW_MAC      0
+#define AQ_HW_MAC_MIN  1
+#define AQ_HW_MAC_MAX  33
+
+#define HW_ATL_B0_MIN_RXD 32
+#define HW_ATL_B0_MIN_TXD 32
+#define HW_ATL_B0_MAX_RXD 4096 /* in fact up to 8184, but closest to power of 2 */
+#define HW_ATL_B0_MAX_TXD 4096 /* in fact up to 8184, but closest to power of 2 */
+
+#define HW_ATL_B0_MTU_JUMBO	16352
+#define HW_ATL_B0_TSO_SIZE	(160 * 1024)
+#define HW_ATL_B0_RINGS_MAX	32
+#define HW_ATL_B0_LRO_RXD_MAX	16
+
+#define AQ_HW_MPI_STATE_MSK	0x00ff
+#define AQ_HW_MPI_STATE_SHIFT	0
+
+#define AQ_HW_MPI_CONTROL_ADR	0x0368
+#define AQ_HW_MPI_STATE_ADR	0x036c
+
+#define HW_ATL_RSS_INDIRECTION_TABLE_MAX	64
+#define HW_ATL_RSS_HASHKEY_SIZE			40
+
+/* PCI core control register */
+#define AQ_HW_PCI_REG_CONTROL_6_ADR		0x1014
+/* tx dma total request limit */
+#define AQ_HW_TX_DMA_TOTAL_REQ_LIMIT_ADR	0x00007b20
+
+#define AQ_HW_TXBUF_MAX		160
+#define AQ_HW_RXBUF_MAX		320
+
+#define L2_FILTER_ACTION_DISCARD	0x0
+#define L2_FILTER_ACTION_HOST		0x1
+
+#define AQ_HW_UCP_0X370_REG	0x370
+#define AQ_HW_CHIP_MIPS		0x00000001
+#define AQ_HW_CHIP_TPO2		0x00000002
+#define AQ_HW_CHIP_RPF2		0x00000004
+#define AQ_HW_CHIP_MPI_AQ	0x00000010
+#define AQ_HW_CHIP_REVISION_A0	0x01000000
+#define AQ_HW_CHIP_REVISION_B0	0x02000000
+#define AQ_HW_CHIP_REVISION_B1	0x04000000
+#define IS_CHIP_FEATURE(HW, _F_) \
+	(AQ_HW_CHIP_##_F_ & (HW)->chip_features)
+
+#define AQ_HW_FW_VER_EXPECTED	0x01050006
+
+#define	AQ_RX_RSS_TYPE_NONE	0x0
+#define	AQ_RX_RSS_TYPE_IPV4	0x2
+#define	AQ_RX_RSS_TYPE_IPV6	0x3
+#define	AQ_RX_RSS_TYPE_IPV4_TCP	0x4
+#define	AQ_RX_RSS_TYPE_IPV6_TCP	0x5
+#define	AQ_RX_RSS_TYPE_IPV4_UDP	0x6
+#define	AQ_RX_RSS_TYPE_IPV6_UDP	0x7
+
+enum hw_atl_rx_action_with_traffic {
+	HW_ATL_RX_DISCARD,
+	HW_ATL_RX_HOST,
+	HW_ATL_RX_MNGMNT,
+	HW_ATL_RX_HOST_AND_MNGMNT,
+	HW_ATL_RX_WOL
+};
+
+typedef struct aq_rx_filter_vlan {
+	uint8_t		enable;
+	uint8_t		location;
+	uint16_t	vlan_id;
+	uint8_t		queue;
+} aq_rx_filter_vlan_t;
+
+#define AQ_HW_VLAN_MAX_FILTERS         16U
+#define AQ_HW_ETYPE_MAX_FILTERS        16U
+
+typedef struct {
+	uint8_t		enable;
+	int8_t		queue;
+	uint8_t		location;
+	uint8_t		user_priority_en;
+	uint8_t		user_priority;
+	uint16_t	ethertype;
+} aq_rx_filter_l2_t;
+
+enum hw_atl_rx_ctrl_registers_l2 {
+	HW_ATL_RX_ENABLE_UNICAST_MNGNT_QUEUE_L2 = BIT(19),
+	HW_ATL_RX_ENABLE_UNICAST_FLTR_L2        = BIT(31)
+};
+
+struct aq_rx_filter_l3l4 {
+	uint32_t cmd;
+	uint8_t location;
+	uint32_t ip_dst[4];
+	uint32_t ip_src[4];
+	uint16_t p_dst;
+	uint16_t p_src;
+	bool is_ipv6;
+};
+
+enum hw_atl_rx_protocol_value_l3l4 {
+	HW_ATL_RX_TCP,
+	HW_ATL_RX_UDP,
+	HW_ATL_RX_SCTP,
+	HW_ATL_RX_ICMP
+};
+
+enum hw_atl_rx_ctrl_registers_l3l4 {
+	HW_ATL_RX_ENABLE_MNGMNT_QUEUE_L3L4 = BIT(22),
+	HW_ATL_RX_ENABLE_QUEUE_L3L4        = BIT(23),
+	HW_ATL_RX_ENABLE_ARP_FLTR_L3       = BIT(24),
+	HW_ATL_RX_ENABLE_CMP_PROT_L4       = BIT(25),
+	HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4  = BIT(26),
+	HW_ATL_RX_ENABLE_CMP_SRC_PORT_L4   = BIT(27),
+	HW_ATL_RX_ENABLE_CMP_DEST_ADDR_L3  = BIT(28),
+	HW_ATL_RX_ENABLE_CMP_SRC_ADDR_L3   = BIT(29),
+	HW_ATL_RX_ENABLE_L3_IPv6           = BIT(30),
+	HW_ATL_RX_ENABLE_FLTR_L3L4         = BIT(31)
+};
+
+#define HW_ATL_RX_BOFFSET_PROT_FL3L4      0
+#define HW_ATL_RX_BOFFSET_QUEUE_FL3L4     8
+#define HW_ATL_RX_BOFFSET_ACTION_FL3F4    16
+
+#define HW_ATL_RX_CNT_REG_ADDR_IPV6       4
+
+#define HW_ATL_GET_REG_LOCATION_FL3L4(location) \
+	((location) - AQ_RX_FIRST_LOC_FL3L4)
+
+int aq_hw_get_mac_permanent(aq_hw_t *, uint8_t *);
+
+int aq_hw_mac_addr_set(aq_hw_t *, uint8_t *, uint8_t);
+
+/* link speed in mbps. "0" - no link detected */
+int aq_hw_get_link_state(aq_hw_t *, uint32_t *, aq_hw_fc_info_t *);
+int aq_hw_set_link_speed(aq_hw_t *, uint32_t);
+int aq_hw_fw_downld_dwords(aq_hw_t *, uint32_t, uint32_t *, uint32_t);
+int aq_hw_reset(aq_hw_t *);
+int aq_hw_mpi_create(aq_hw_t *);
+int aq_hw_mpi_read_stats(aq_hw_t *, aq_hw_fw_mbox_t *);
+int aq_hw_init(aq_hw_t *, uint8_t *, uint8_t, bool);
+int aq_hw_start(aq_hw_t *);
+int aq_hw_interrupt_moderation_set(aq_hw_t *);
+int aq_hw_get_fw_version(aq_hw_t *, uint32_t *);
+int aq_hw_deinit(aq_hw_t *);
+void aq_hw_set_promisc(aq_hw_t *, bool, bool, bool);
+int aq_hw_set_power(aq_hw_t *, unsigned int);
+int aq_hw_err_from_flags(aq_hw_t *);
+
+int hw_atl_b0_hw_vlan_promisc_set(aq_hw_t *, bool);
+int hw_atl_b0_hw_vlan_set(aq_hw_t *, aq_rx_filter_vlan_t *);
+
+/* FIXME fix these monstrosities */
+int aq_hw_rss_hash_set(aq_hw_t *, uint8_t rss_key[HW_ATL_RSS_HASHKEY_SIZE]);
+int aq_hw_rss_hash_get(aq_hw_t *, uint8_t rss_key[HW_ATL_RSS_HASHKEY_SIZE]);
+int aq_hw_rss_set(aq_hw_t *, uint8_t rss_table[HW_ATL_RSS_INDIRECTION_TABLE_MAX]);
+int aq_hw_udp_rss_enable(aq_hw_t *, bool);
+
+#define aq_fw_speed_auto (aq_fw_100M | aq_fw_1G | aq_fw_2G5 | aq_fw_5G | aq_fw_10G)
+
+int aq_fw_reset(aq_hw_t *hw);
+int aq_fw_ops_init(aq_hw_t *hw);
+
+enum aq_media_type {
+	AQ_MEDIA_TYPE_UNKNOWN = 0,
+	AQ_MEDIA_TYPE_FIBRE,
+	AQ_MEDIA_TYPE_TP,
+};
+
+#define	AQ_LINK_UNKNOWN	0x00000000
+#define	AQ_LINK_100M	0x00000001
+#define	AQ_LINK_1G	0x00000002
+#define	AQ_LINK_2G5	0x00000004
+#define	AQ_LINK_5G	0x00000008
+#define	AQ_LINK_10G	0x00000010
+
+#define	AQ_LINK_ALL	\
+	(AQ_LINK_100M | AQ_LINK_1G | AQ_LINK_2G5 | AQ_LINK_5G | AQ_LINK_10G)
+
+typedef struct aq_stats_s {
+	uint64_t	prc;
+	uint64_t	uprc;
+	uint64_t	mprc;
+	uint64_t	bprc;
+	uint64_t	cprc;
+	uint64_t	erpr;
+	uint64_t	dpc;
+	uint64_t	brc;
+	uint64_t	ubrc;
+	uint64_t	mbrc;
+	uint64_t	bbrc;
+
+	uint64_t	ptc;
+	uint64_t	uptc;
+	uint64_t	mptc;
+	uint64_t	bptc;
+	uint64_t	erpt;
+	uint64_t	btc;
+	uint64_t	ubtc;
+	uint64_t	mbtc;
+	uint64_t	bbtc;
+} aq_stats_t;
+
+typedef enum {
+    AQ_DEV_STATE_UNLOAD,
+    AQ_DEV_STATE_PCI_STOP,
+    AQ_DEV_STATE_DOWN,
+    AQ_DEV_STATE_UP,
+} aq_dev_state_t;
+
+struct aq_rx_filters {
+	unsigned int	rule_cnt;
+	aq_rx_filter_vlan_t vlan_filters[AQ_HW_VLAN_MAX_FILTERS];
+	aq_rx_filter_l2_t etype_filters[AQ_HW_ETYPE_MAX_FILTERS];
+};
+
+typedef struct {
+	SLIST_ENTRY(aq_vlan_tag) next;
+	uint16_t	tag;
+} aq_vlan_tag_t;
+
+typedef struct aq_ring aq_ring_t;
+
+typedef struct aq_dev {
+	device_t		dev;
+	if_ctx_t		ctx;
+	if_softc_ctx_t		scctx;
+	if_shared_ctx_t		sctx;
+	struct ifmedia		*media;
+
+	aq_hw_t			hw;
+
+	enum aq_media_type	media_type;
+	uint32_t		link_speeds;
+	uint32_t		chip_features;
+	uint32_t		mbox_addr;
+	uint8_t			mac_addr[ETHER_ADDR_LEN];
+	uint64_t		admin_ticks;
+	struct if_irq		irq;
+	int			msix;
+
+	int			mmio_rid;
+	struct resource *	mmio_res;
+	bus_space_tag_t		mmio_tag;
+	bus_space_handle_t	mmio_handle;
+	bus_size_t		mmio_size;
+
+	aq_ring_t		*tx_rings[HW_ATL_B0_RINGS_MAX];
+	aq_ring_t		*rx_rings[HW_ATL_B0_RINGS_MAX];
+	uint32_t		tx_rings_count;
+	uint32_t		rx_rings_count;
+	bool			linkup;
+	int			media_active;
+
+	aq_hw_stats_t		last_stats;
+	aq_stats_t		curr_stats;
+
+	bitstr_t		*vlan_tags;
+	int			mcnt;
+
+	uint8_t			rss_key[HW_ATL_RSS_HASHKEY_SIZE];
+	uint8_t			rss_table[HW_ATL_RSS_INDIRECTION_TABLE_MAX];
+} aq_dev_t;
+
+int aq_update_hw_stats(aq_dev_t *aq_dev);
+void aq_initmedia(aq_dev_t *aq_dev);
+int aq_linkstat_isr(void *arg);
+int aq_isr_rx(void *arg);
+void aq_mediastatus_update(aq_dev_t *, uint32_t, const aq_hw_fc_info_t *);
+void aq_mediastatus(if_t, struct ifmediareq *);
+int aq_mediachange(if_t);
+void aq_if_update_admin_status(if_ctx_t);
+
+#define REFILL_THRESHOLD 128
+
+typedef volatile struct {
+    uint32_t	rss_type:4;
+    uint32_t	pkt_type:8;
+    uint32_t	rdm_err:1;
+    uint32_t	rsvd:6;
+    uint32_t	rx_cntl:2;
+    uint32_t	sph:1;
+    uint32_t	hdr_len:10;
+    uint32_t	rss_hash;
+    uint16_t	dd:1;
+    uint16_t	eop:1;
+    uint16_t	rx_stat:4;
+    uint16_t	rx_estat:6;
+    uint16_t	rsc_cnt:4;
+    uint16_t	pkt_len;
+    uint16_t	next_desp;
+    uint16_t	vlan;
+} __packed aq_rx_wb_t;
+
+/* Hardware RX descriptor */
+typedef volatile struct {
+	union {
+		/* HW RX descriptor */
+		struct {
+			uint64_t	buf_addr;
+			uint64_t	hdr_addr;
+		} __packed read;
+		/* HW RX descriptor writeback */
+		aq_rx_wb_t	wb;
+	};
+} __packed aq_rx_desc_t;
+
+/* Hardware TX descriptor */
+typedef volatile struct {
+	uint64_t buf_addr;
+	union {
+		struct {
+			uint32_t	type:3;
+			uint32_t	:1;
+			uint32_t	len:16;
+			uint32_t	dd:1;
+			uint32_t	eop:1;
+			uint32_t	cmd:8;
+			uint32_t	:14;
+			uint32_t	ct_idx:1;
+			uint32_t	ct_en:1;
+			uint32_t	pay_len:18;
+		} __packed;
+		uint64_t flags;
+	};
+} __packed aq_tx_desc_t;
+
+enum {
+	tx_desc_type_desc = 1,
+	tx_desc_type_ctx = 2,
+};
+
+enum {
+	tx_desc_cmd_vlan = 1,
+	tx_desc_cmd_fcs = 2,
+	tx_desc_cmd_ipv4 = 4,
+	tx_desc_cmd_l4cs = 8,
+	tx_desc_cmd_lso = 0x10,
+	tx_desc_cmd_wb = 0x20,
+};
+
+/* Hardware TX context descriptor */
+typedef volatile union {
+	struct {
+		uint64_t	flags1;
+		uint64_t	flags2;
+	} __packed;
+	struct {
+		uint64_t	:40;
+		uint32_t	tun_len:8;
+		uint32_t	out_len:16;
+		uint32_t	type:3;
+		uint32_t	idx:1;
+		uint32_t	vlan_tag:16;
+		uint32_t	cmd:4;
+		uint32_t	l2_len:7;
+		uint32_t	l3_len:9;
+		uint32_t	l4_len:8;
+		uint32_t	mss_len:16;
+	} __packed;
+} __packed aq_txc_desc_t;
+
+typedef struct {
+	uint64_t rx_pkts;
+	uint64_t rx_bytes;
+	uint64_t jumbo_pkts;
+	uint64_t rx_err;
+	uint64_t irq;
+
+	uint64_t tx_pkts;
+	uint64_t tx_bytes;
+	uint64_t tx_drops;
+	uint64_t tx_queue_full;
+} aq_ring_stats_t;
+
+struct aq_ring {
+	aq_dev_t	*dev;
+	int		index;
+
+	struct if_irq	irq;
+	int		msix;
+	/* RX */
+	qidx_t		rx_size;
+	int		rx_max_frame_size;
+	void		*rx_desc_area_ptr;
+	aq_rx_desc_t	*rx_descs;
+	uint64_t	rx_descs_phys;
+
+	/* TX */
+	int		tx_head, tx_tail;
+	qidx_t		tx_size;
+	void		*tx_desc_area_ptr;
+	aq_tx_desc_t	*tx_descs;
+	uint64_t	tx_descs_phys;
+
+	aq_ring_stats_t	stats;
+};
+
+int aq_ring_rx_init(aq_hw_t *, aq_ring_t *);
+int aq_ring_tx_init(aq_hw_t *, aq_ring_t *);
+
+int aq_ring_tx_start(aq_hw_t *, aq_ring_t *);
+int aq_ring_tx_stop(aq_hw_t *, aq_ring_t *);
+int aq_ring_rx_start(aq_hw_t *, aq_ring_t *);
+int aq_ring_rx_stop(aq_hw_t *, aq_ring_t *);
+
+int aq_ring_tx_tail_update(aq_hw_t *, aq_ring_t *, uint32_t);
+
+extern struct if_txrx aq_txrx;
+int aq_intr(void *);
+
+int aq_hw_ver_match(const aq_hw_fw_version *, const aq_hw_fw_version *);
+
+#endif	/* !_AQ_H_ */
diff --git aq_common.h aq_common.h
deleted file mode 100644
index b123a7e..0000000
--- aq_common.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * aQuantia Corporation Network Driver
- * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   (1) Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer.
- *
- *   (2) Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer in the documentation and/or other materials provided
- *   with the distribution.
- *
- *   (3)The name of the author may not be used to endorse or promote
- *   products derived from this software without specific prior
- *   written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _AQ_COMMON_H_
-#define _AQ_COMMON_H_
-
-#include <stdint.h>
-
-#define ETH_MAC_LEN 6
-
-/* Types definition */
-#define TRUE     1
-#define FALSE    0
-
-#define s8       __int8_t
-#define u8       __uint8_t
-#define u16      __uint16_t
-#define s16      __int16_t
-#define u32      __uint32_t
-#define u64      __uint64_t
-#define s64      __int64_t
-#define s32      int
-typedef __uint32_t DWORD;
-
-#define ETIME ETIMEDOUT
-#define EOK 0
-
-#define BIT(nr) (1UL << (nr))
-
-#define usec_delay(x) DELAY(x)
-
-#ifndef msec_delay
-#define msec_delay(x) DELAY(x*1000)
-#define msec_delay_irq(x) DELAY(x*1000)
-#endif
-
-#define AQ_HW_WAIT_FOR(_B_, _US_, _N_) \
-    do { \
-        unsigned int i; \
-        for (i = _N_; (!(_B_)) && i; --i) { \
-            usec_delay(_US_); \
-        } \
-        if (!i) { \
-            err = -1; \
-        } \
-    } while (0)
-
-
-#define LODWORD(a) ((DWORD)(a))
-#define LOWORD(a) ((u16)(a))
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-
-#define AQ_VER        "0.0.5"
-
-#endif //_AQ_COMMON_H_
-
diff --git aq_dbg.c aq_dbg.c
index 5340fc4..50de871 100644
--- aq_dbg.c
+++ aq_dbg.c
@@ -41,7 +41,7 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
-#include "aq_common.h"
+#include "aq.h"
 #include "aq_dbg.h"
 
 
@@ -234,4 +234,4 @@ void DumpHex(const void* data, size_t size) {
 		}
 	}
 #endif
-}
\ No newline at end of file
+}
diff --git aq_device.h aq_device.h
deleted file mode 100644
index 2c0d8df..0000000
--- aq_device.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * aQuantia Corporation Network Driver
- * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   (1) Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer.
- *
- *   (2) Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer in the documentation and/or other materials provided
- *   with the distribution.
- *
- *   (3)The name of the author may not be used to endorse or promote
- *   products derived from this software without specific prior
- *   written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _AQ_DEVICE_H_
-#define _AQ_DEVICE_H_
-
-#include "aq_hw.h"
-
-enum aq_media_type {
-	AQ_MEDIA_TYPE_UNKNOWN = 0,
-	AQ_MEDIA_TYPE_FIBRE,
-	AQ_MEDIA_TYPE_TP,
-};
-
-#define	AQ_LINK_UNKNOWN	0x00000000
-#define	AQ_LINK_100M	0x00000001
-#define	AQ_LINK_1G		0x00000002
-#define	AQ_LINK_2G5		0x00000004
-#define	AQ_LINK_5G		0x00000008
-#define	AQ_LINK_10G		0x00000010
-
-#define	AQ_LINK_ALL	(AQ_LINK_100M | AQ_LINK_1G | AQ_LINK_2G5 | AQ_LINK_5G | \
-					 AQ_LINK_10G )
-
-struct aq_stats_s {
-    u64 prc;
-    u64 uprc;
-    u64 mprc;
-    u64 bprc;
-    u64 cprc;
-    u64 erpr;
-    u64 dpc;
-    u64 brc;
-    u64 ubrc;
-    u64 mbrc;
-    u64 bbrc;
-
-    u64 ptc;
-    u64 uptc;
-    u64 mptc;
-    u64 bptc;
-    u64 erpt;
-    u64 btc;
-    u64 ubtc;
-    u64 mbtc;
-    u64 bbtc;
-};
-
-enum aq_dev_state_e {
-    AQ_DEV_STATE_UNLOAD,
-    AQ_DEV_STATE_PCI_STOP,
-    AQ_DEV_STATE_DOWN,
-    AQ_DEV_STATE_UP,
-};
-
-struct aq_rx_filters {
-    unsigned int rule_cnt;
-    struct aq_rx_filter_vlan vlan_filters[AQ_HW_VLAN_MAX_FILTERS];
-    struct aq_rx_filter_l2 etype_filters[AQ_HW_ETYPE_MAX_FILTERS];
-};
-
-struct aq_vlan_tag {
-	SLIST_ENTRY(aq_vlan_tag) next;
-	uint16_t	tag;
-};
-
-struct aq_dev {
-	device_t		dev;
-	if_ctx_t		ctx;
-	if_softc_ctx_t		scctx;
-	if_shared_ctx_t		sctx;
-	struct ifmedia *	media;
-
-    struct aq_hw          hw;
-
-	enum aq_media_type	media_type;
-	uint32_t		link_speeds;
-	uint32_t		chip_features;
-	uint32_t		mbox_addr;
-	uint8_t			mac_addr[ETHER_ADDR_LEN];
-	uint64_t		admin_ticks;
-	struct if_irq	irq;
-	int				msix;
-
-	int			mmio_rid;
-	struct resource *	mmio_res;
-	bus_space_tag_t		mmio_tag;
-	bus_space_handle_t	mmio_handle;
-	bus_size_t		mmio_size;
-
-	struct aq_ring    *tx_rings[HW_ATL_B0_RINGS_MAX];
-	struct aq_ring    *rx_rings[HW_ATL_B0_RINGS_MAX];
-	uint32_t          tx_rings_count;
-	uint32_t          rx_rings_count;
-	bool              linkup;
-	int               media_active;
-
-	struct aq_hw_stats_s  last_stats;
-	struct aq_stats_s     curr_stats;
-
-	bitstr_t               *vlan_tags;
-	int                     mcnt;
-
-	uint8_t			rss_key[HW_ATL_RSS_HASHKEY_SIZE];
-	uint8_t			rss_table[HW_ATL_RSS_INDIRECTION_TABLE_MAX];
-};
-
-typedef struct aq_dev aq_dev_t;
-
-int aq_update_hw_stats(aq_dev_t *aq_dev);
-void aq_initmedia(aq_dev_t *aq_dev);
-int aq_linkstat_isr(void *arg);
-int aq_isr_rx(void *arg);
-void aq_mediastatus_update(aq_dev_t *aq_dev, u32 link_speed, const struct aq_hw_fc_info *fc_neg);
-void aq_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr);
-int aq_mediachange(struct ifnet *ifp);
-void aq_if_update_admin_status(if_ctx_t ctx);
-
-#endif
diff --git aq_fw.c aq_fw.c
index 619a304..d7ef1f5 100644
--- aq_fw.c
+++ aq_fw.c
@@ -41,15 +41,11 @@ __FBSDID("$FreeBSD$");
 
 #include <errno.h>
 
-#include "aq_common.h"
+#include "aq.h"
 
-#include "aq_hw.h"
 #include "aq_hw_llh.h"
 #include "aq_hw_llh_internal.h"
 
-#include "aq_fw.h"
-#include "aq_common.h"
-
 #include "aq_dbg.h"
 
 
diff --git aq_fw.h aq_fw.h
deleted file mode 100644
index 7ffb60b..0000000
--- aq_fw.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * aQuantia Corporation Network Driver
- * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   (1) Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer.
- *
- *   (2) Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer in the documentation and/or other materials provided
- *   with the distribution.
- *
- *   (3) The name of the author may not be used to endorse or promote
- *   products derived from this software without specific prior
- *   written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef AQ_FW_H
-#define AQ_FW_H
-
-struct aq_hw;
-
-typedef enum aq_fw_link_speed
-{
-    aq_fw_none  = 0,
-    aq_fw_100M  = (1 << 0),
-    aq_fw_1G    = (1 << 1),
-    aq_fw_2G5   = (1 << 2),
-    aq_fw_5G    = (1 << 3),
-    aq_fw_10G   = (1 << 4),
-} aq_fw_link_speed_t;
-
-typedef enum aq_fw_link_fc
-{
-    aq_fw_fc_none  = 0,
-    aq_fw_fc_ENABLE_RX = BIT(0),
-    aq_fw_fc_ENABLE_TX = BIT(1),
-    aq_fw_fc_ENABLE_ALL = aq_fw_fc_ENABLE_RX | aq_fw_fc_ENABLE_TX,
-} aq_fw_link_fc_t;
-
-#define aq_fw_speed_auto (aq_fw_100M | aq_fw_1G | aq_fw_2G5 | aq_fw_5G | aq_fw_10G)
-
-struct aq_firmware_ops
-{
-    int (*reset)(struct aq_hw* hal);
-
-    int (*set_mode)(struct aq_hw* hal, enum aq_hw_fw_mpi_state_e mode, aq_fw_link_speed_t speed);
-    int (*get_mode)(struct aq_hw* hal, enum aq_hw_fw_mpi_state_e* mode, aq_fw_link_speed_t* speed, aq_fw_link_fc_t* fc);
-
-    int (*get_mac_addr)(struct aq_hw* hal, u8* mac_addr);
-    int (*get_stats)(struct aq_hw* hal, struct aq_hw_stats_s* stats);
-
-    int (*led_control)(struct aq_hw* hal, u32 mode);
-};
-
-
-int aq_fw_reset(struct aq_hw* hw);
-int aq_fw_ops_init(struct aq_hw* hw);
-
-#endif // AQ_FW_H
diff --git aq_fw1x.c aq_fw1x.c
index 97bbbfc..dc713cf 100644
--- aq_fw1x.c
+++ aq_fw1x.c
@@ -37,11 +37,9 @@ __FBSDID("$FreeBSD$");
 
 #include <errno.h>
 
-#include "aq_common.h"
-#include "aq_hw.h"
+#include "aq.h"
 #include "aq_hw_llh.h"
 #include "aq_hw_llh_internal.h"
-#include "aq_fw.h"
 #include "aq_dbg.h"
 
 
diff --git aq_fw2x.c aq_fw2x.c
index c76a034..c73d5c0 100644
--- aq_fw2x.c
+++ aq_fw2x.c
@@ -40,15 +40,11 @@ __FBSDID("$FreeBSD$");
 
 #include <errno.h>
 
-#include "aq_common.h"
+#include "aq.h"
 
-
-#include "aq_hw.h"
 #include "aq_hw_llh.h"
 #include "aq_hw_llh_internal.h"
 
-#include "aq_fw.h"
-
 #include "aq_dbg.h"
 
 typedef enum {
diff --git aq_hw.c aq_hw.c
index 3b17644..7b18a51 100644
--- aq_hw.c
+++ aq_hw.c
@@ -32,7 +32,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <unistd.h>
 #include <sys/endian.h>
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -40,10 +39,9 @@
 #include <sys/socket.h>
 #include <net/if.h>
 
-#include "aq_hw.h"
+#include "aq.h"
 #include "aq_dbg.h"
 #include "aq_hw_llh.h"
-#include "aq_fw.h"
 
 #define AQ_HW_FW_SM_RAM        0x2U
 #define AQ_CFG_FW_MIN_VER_EXPECTED 0x01050006U
diff --git aq_hw.h aq_hw.h
deleted file mode 100644
index bf7f289..0000000
--- aq_hw.h
+++ /dev/null
@@ -1,356 +0,0 @@
-/*
- * aQuantia Corporation Network Driver
- * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   (1) Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer.
- *
- *   (2) Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer in the documentation and/or other materials provided
- *   with the distribution.
- *
- *   (3)The name of the author may not be used to endorse or promote
- *   products derived from this software without specific prior
- *   written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _AQ_HW_H_
-#define _AQ_HW_H_
-
-#include <stdbool.h>
-#include <sys/types.h>
-#include <sys/cdefs.h>
-#include <machine/cpufunc.h>
-#include <sys/endian.h>
-#include "aq_common.h"
-
-#define AQ_WRITE_REG(hw, reg, value) writel(((hw)->hw_addr + (reg)), htole32(value))
-    
-#define AQ_READ_REG(hw, reg) le32toh(readl((hw)->hw_addr + reg))
-
-
-#define AQ_WRITE_REG_BIT(hw, reg, msk, shift, value) do { \
-    if (msk ^ ~0) { \
-        u32 reg_old, reg_new = 0U; \
-        reg_old = AQ_READ_REG(hw, reg); \
-        reg_new = (reg_old & (~msk)) | (value << shift); \
-        if (reg_old != reg_new) \
-            AQ_WRITE_REG(hw, reg, reg_new); \
-    } else { \
-        AQ_WRITE_REG(hw, reg, value); \
-    } } while(0)
-
-
-#define AQ_READ_REG_BIT(a, reg, msk, shift) ( \
-    ((AQ_READ_REG(a, reg) & msk) >> shift))        
-
-#define AQ_HW_FLUSH() { (void)AQ_READ_REG(hw, 0x10); }
-
-#define aq_hw_write_reg_bit AQ_WRITE_REG_BIT
-
-#define aq_hw_write_reg AQ_WRITE_REG
-
-/* Statistics  */
-struct aq_hw_stats {
-    u64 crcerrs;
-};
-
-struct aq_hw_stats_s {
-    u32 uprc;
-    u32 mprc;
-    u32 bprc;
-    u32 erpt;
-    u32 uptc;
-    u32 mptc;
-    u32 bptc;
-    u32 erpr;
-    u32 mbtc;
-    u32 bbtc;
-    u32 mbrc;
-    u32 bbrc;
-    u32 ubrc;
-    u32 ubtc;
-    u32 ptc;
-    u32 prc;
-    u32 dpc;
-    u32 cprc;
-} __attribute__((__packed__));
-
-union ip_addr {
-    struct {
-        u8 addr[16];
-    } v6;
-    struct {
-        u8 padding[12];
-        u8 addr[4];
-    } v4;
-} __attribute__((__packed__));
-
-struct aq_hw_fw_mbox {
-    u32 version;
-    u32 transaction_id;
-    int error;
-    struct aq_hw_stats_s stats;
-} __attribute__((__packed__));
-
-typedef struct aq_hw_fw_version {
-    union {
-        struct {
-            u16 build_number;
-            u8 minor_version;
-            u8 major_version;
-        };
-        u32 raw;
-    };
-} aq_hw_fw_version;
-
-enum aq_hw_irq_type {
-    aq_irq_invalid = 0,
-    aq_irq_legacy = 1,
-    aq_irq_msi = 2,
-    aq_irq_msix = 3,
-};
-
-struct aq_hw_fc_info {
-    bool fc_rx;
-    bool fc_tx;
-};
-
-struct aq_hw {
-    void *aq_dev;
-    u8 *hw_addr;
-    u32 regs_size;
-
-    u8 mac_addr[ETH_MAC_LEN];
-
-    enum aq_hw_irq_type irq_type;
-    
-    struct aq_hw_fc_info fc;
-    u16 link_rate;
-
-    u16 device_id;
-    u16 subsystem_vendor_id;
-    u16 subsystem_device_id;
-    u16 vendor_id;
-    u8  revision_id;
-
-    /* Interrupt Moderation value. */
-    int itr;
-
-    /* Firmware-related stuff. */
-    aq_hw_fw_version fw_version;
-    const struct aq_firmware_ops* fw_ops;
-    bool rbl_enabled;
-    bool fast_start_enabled;
-    bool flash_present;
-    u32 chip_features;
-    u64 fw_caps;
-
-	bool lro_enabled;
-
-    u32 mbox_addr;
-    struct aq_hw_fw_mbox mbox;
-};
-
-#define aq_hw_s aq_hw
-
-#define AQ_HW_MAC      0U
-#define AQ_HW_MAC_MIN  1U
-#define AQ_HW_MAC_MAX  33U
-
-#define HW_ATL_B0_MIN_RXD 32U
-#define HW_ATL_B0_MIN_TXD 32U
-#define HW_ATL_B0_MAX_RXD 4096U /* in fact up to 8184, but closest to power of 2 */
-#define HW_ATL_B0_MAX_TXD 4096U /* in fact up to 8184, but closest to power of 2 */
-
-#define HW_ATL_B0_MTU_JUMBO  16352U
-#define HW_ATL_B0_TSO_SIZE (160*1024)
-#define HW_ATL_B0_RINGS_MAX 32U
-#define HW_ATL_B0_LRO_RXD_MAX 16U
-
-#define AQ_HW_FW_SM_RAM        0x2U
-
-#define AQ_HW_MPI_STATE_MSK    0x00FFU
-#define AQ_HW_MPI_STATE_SHIFT  0U
-
-#define AQ_HW_MPI_CONTROL_ADR       0x0368U
-#define AQ_HW_MPI_STATE_ADR         0x036CU
-
-#define HW_ATL_RSS_INDIRECTION_TABLE_MAX  64U
-#define HW_ATL_RSS_HASHKEY_SIZE           40U
-
-/* PCI core control register */
-#define AQ_HW_PCI_REG_CONTROL_6_ADR 0x1014U
-/* tx dma total request limit */
-#define AQ_HW_TX_DMA_TOTAL_REQ_LIMIT_ADR 0x00007b20U
-
-#define AQ_HW_TXBUF_MAX  160U
-#define AQ_HW_RXBUF_MAX  320U
-
-#define L2_FILTER_ACTION_DISCARD (0x0)
-#define L2_FILTER_ACTION_HOST    (0x1)
-
-#define AQ_HW_UCP_0X370_REG  (0x370)
-#define AQ_HW_CHIP_MIPS         0x00000001U
-#define AQ_HW_CHIP_TPO2         0x00000002U
-#define AQ_HW_CHIP_RPF2         0x00000004U
-#define AQ_HW_CHIP_MPI_AQ       0x00000010U
-#define AQ_HW_CHIP_REVISION_A0  0x01000000U
-#define AQ_HW_CHIP_REVISION_B0  0x02000000U
-#define AQ_HW_CHIP_REVISION_B1  0x04000000U
-#define IS_CHIP_FEATURE(HW, _F_) (AQ_HW_CHIP_##_F_ & \
-    (HW)->chip_features)
-
-#define AQ_HW_FW_VER_EXPECTED 0x01050006U
-
-#define	AQ_RX_RSS_TYPE_NONE		0x0
-#define	AQ_RX_RSS_TYPE_IPV4		0x2
-#define	AQ_RX_RSS_TYPE_IPV6		0x3
-#define	AQ_RX_RSS_TYPE_IPV4_TCP	0x4
-#define	AQ_RX_RSS_TYPE_IPV6_TCP	0x5
-#define	AQ_RX_RSS_TYPE_IPV4_UDP	0x6
-#define	AQ_RX_RSS_TYPE_IPV6_UDP	0x7
-
-enum hw_atl_rx_action_with_traffic {
-	HW_ATL_RX_DISCARD,
-	HW_ATL_RX_HOST,
-	HW_ATL_RX_MNGMNT,
-	HW_ATL_RX_HOST_AND_MNGMNT,
-	HW_ATL_RX_WOL
-};
-
-struct aq_rx_filter_vlan {
-	u8 enable;
-	u8 location;
-	u16 vlan_id;
-	u8 queue;
-};
-
-#define AQ_HW_VLAN_MAX_FILTERS         16U
-#define AQ_HW_ETYPE_MAX_FILTERS        16U
-
-struct aq_rx_filter_l2 {
-	u8 enable;
-	s8 queue;
-	u8 location;
-	u8 user_priority_en;
-	u8 user_priority;
-	u16 ethertype;
-};
-
-enum hw_atl_rx_ctrl_registers_l2 {
-	HW_ATL_RX_ENABLE_UNICAST_MNGNT_QUEUE_L2 = BIT(19),
-	HW_ATL_RX_ENABLE_UNICAST_FLTR_L2        = BIT(31)
-};
-
-struct aq_rx_filter_l3l4 {
-	u32 cmd;
-	u8 location;
-	u32 ip_dst[4];
-	u32 ip_src[4];
-	u16 p_dst;
-	u16 p_src;
-	bool is_ipv6;
-};
-
-enum hw_atl_rx_protocol_value_l3l4 {
-	HW_ATL_RX_TCP,
-	HW_ATL_RX_UDP,
-	HW_ATL_RX_SCTP,
-	HW_ATL_RX_ICMP
-};
-
-enum hw_atl_rx_ctrl_registers_l3l4 {
-	HW_ATL_RX_ENABLE_MNGMNT_QUEUE_L3L4 = BIT(22),
-	HW_ATL_RX_ENABLE_QUEUE_L3L4        = BIT(23),
-	HW_ATL_RX_ENABLE_ARP_FLTR_L3       = BIT(24),
-	HW_ATL_RX_ENABLE_CMP_PROT_L4       = BIT(25),
-	HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4  = BIT(26),
-	HW_ATL_RX_ENABLE_CMP_SRC_PORT_L4   = BIT(27),
-	HW_ATL_RX_ENABLE_CMP_DEST_ADDR_L3  = BIT(28),
-	HW_ATL_RX_ENABLE_CMP_SRC_ADDR_L3   = BIT(29),
-	HW_ATL_RX_ENABLE_L3_IPv6           = BIT(30),
-	HW_ATL_RX_ENABLE_FLTR_L3L4         = BIT(31)
-};
-
-#define HW_ATL_RX_BOFFSET_PROT_FL3L4      0U
-#define HW_ATL_RX_BOFFSET_QUEUE_FL3L4     8U
-#define HW_ATL_RX_BOFFSET_ACTION_FL3F4    16U
-
-#define HW_ATL_RX_CNT_REG_ADDR_IPV6       4U
-
-#define HW_ATL_GET_REG_LOCATION_FL3L4(location) \
-	((location) - AQ_RX_FIRST_LOC_FL3L4)
-
-enum aq_hw_fw_mpi_state_e {
-    MPI_DEINIT = 0,
-    MPI_RESET = 1,
-    MPI_INIT = 2,
-    MPI_POWER = 4,
-};
-
-int aq_hw_get_mac_permanent(struct aq_hw *hw, u8 *mac);
-
-int aq_hw_mac_addr_set(struct aq_hw *hw, u8 *mac_addr, u8 index);
-
-/* link speed in mbps. "0" - no link detected */
-int aq_hw_get_link_state(struct aq_hw *hw, u32 *link_speed, struct aq_hw_fc_info *fc_neg);
-
-int aq_hw_set_link_speed(struct aq_hw *hw, u32 speed);
-
-int aq_hw_fw_downld_dwords(struct aq_hw *hw, u32 a, u32 *p, u32 cnt);
-
-int aq_hw_reset(struct aq_hw *hw);
-
-int aq_hw_mpi_create(struct aq_hw *hw);
-
-int aq_hw_mpi_read_stats(struct aq_hw *hw, struct aq_hw_fw_mbox *pmbox);
-
-int aq_hw_init(struct aq_hw *hw, u8 *mac_addr, u8 adm_irq, bool msix);
-
-int aq_hw_start(struct aq_hw *hw);
-
-int aq_hw_interrupt_moderation_set(struct aq_hw *hw);
-
-int aq_hw_get_fw_version(struct aq_hw *hw, u32 *fw_version);
-
-int aq_hw_deinit(struct aq_hw *hw);
-
-int aq_hw_ver_match(const aq_hw_fw_version* ver_expected, const aq_hw_fw_version* ver_actual);
-
-void aq_hw_set_promisc(struct aq_hw_s *self, bool l2_promisc, bool vlan_promisc, bool mc_promisc);
-
-int aq_hw_set_power(struct aq_hw *hw, unsigned int power_state);
-
-int aq_hw_err_from_flags(struct aq_hw *hw);
-
-int hw_atl_b0_hw_vlan_promisc_set(struct aq_hw_s *self, bool promisc);
-
-int hw_atl_b0_hw_vlan_set(struct aq_hw_s *self,
-                  struct aq_rx_filter_vlan *aq_vlans);
-
-int aq_hw_rss_hash_set(struct aq_hw_s *self, u8 rss_key[HW_ATL_RSS_HASHKEY_SIZE]);
-int aq_hw_rss_hash_get(struct aq_hw_s *self, u8 rss_key[HW_ATL_RSS_HASHKEY_SIZE]);
-int aq_hw_rss_set(struct aq_hw_s *self, u8 rss_table[HW_ATL_RSS_INDIRECTION_TABLE_MAX]);
-int aq_hw_udp_rss_enable(struct aq_hw_s *self, bool enable);
-
-#endif //_AQ_HW_H_
-
diff --git aq_hw_llh.c aq_hw_llh.c
index b5e9182..165e15a 100644
--- aq_hw_llh.c
+++ aq_hw_llh.c
@@ -36,7 +36,7 @@
  * Atlantic registers.
  */
 
-#include "aq_hw.h"
+#include "aq.h"
 #include "aq_hw_llh.h"
 #include "aq_hw_llh_internal.h"
 
diff --git aq_hw_llh.h aq_hw_llh.h
index 8d01448..a7bf082 100644
--- aq_hw_llh.h
+++ aq_hw_llh.h
@@ -39,7 +39,7 @@
 #ifndef HW_ATL_LLH_H
 #define HW_ATL_LLH_H
 
-#include "aq_common.h"
+#include "aq.h"
 
 struct aq_hw;
 
diff --git aq_irq.c aq_irq.c
index 4ffccc0..aa4a32f 100644
--- aq_irq.c
+++ aq_irq.c
@@ -47,11 +47,8 @@ __FBSDID("$FreeBSD$");
 #include <net/ethernet.h>
 #include <net/iflib.h>
 
-#include "aq_common.h"
-#include "aq_device.h"
-#include "aq_ring.h"
+#include "aq.h"
 #include "aq_dbg.h"
-#include "aq_hw.h"
 #include "aq_hw_llh.h"
 
 int aq_update_hw_stats(aq_dev_t *aq_dev)
diff --git aq_main.c aq_main.c
index 299ed79..b6dbe47 100644
--- aq_main.c
+++ aq_main.c
@@ -70,11 +70,8 @@ __FBSDID("$FreeBSD$");
 
 #include "ifdi_if.h"
 
-#include "aq_device.h"
-#include "aq_fw.h"
-#include "aq_hw.h"
+#include "aq.h"
 #include "aq_hw_llh.h"
-#include "aq_ring.h"
 #include "aq_dbg.h"
 
 
@@ -160,7 +157,7 @@ static int aq_if_media_change(if_ctx_t ctx);
 static int aq_if_promisc_set(if_ctx_t ctx, int flags);
 static uint64_t aq_if_get_counter(if_ctx_t ctx, ift_counter cnt);
 static void aq_if_timer(if_ctx_t ctx, uint16_t qid);
-static int aq_if_priv_ioctl(if_ctx_t ctx, u_long command, caddr_t data);
+//static int aq_if_priv_ioctl(if_ctx_t ctx, u_long command, caddr_t data);
 static int aq_hw_capabilities(struct aq_dev *softc);
 static void aq_add_stats_sysctls(struct aq_dev *softc);
 
@@ -177,7 +174,7 @@ static void aq_if_vlan_register(if_ctx_t ctx, uint16_t vtag);
 static void aq_if_vlan_unregister(if_ctx_t ctx, uint16_t vtag);
 
 /* Informational/diagnostic */
-static void	aq_if_debug(if_ctx_t ctx);
+//static void	aq_if_debug(if_ctx_t ctx);
 static void	aq_if_led_func(if_ctx_t ctx, int onoff);
 
 static device_method_t aq_methods[] = {
@@ -196,8 +193,7 @@ static driver_t aq_driver = {
 	"aq", aq_methods, sizeof(struct aq_dev),
 };
 
-static devclass_t aq_devclass;
-DRIVER_MODULE(atlantic, pci, aq_driver, aq_devclass, 0, 0);
+DRIVER_MODULE(atlantic, pci, aq_driver, 0, 0);
 
 MODULE_DEPEND(atlantic, pci, 1, 1, 1);
 MODULE_DEPEND(atlantic, ether, 1, 1, 1);
diff --git aq_media.c aq_media.c
index 914d3d3..ce423f2 100644
--- aq_media.c
+++ aq_media.c
@@ -46,9 +46,7 @@ __FBSDID("$FreeBSD$");
 #include <net/ethernet.h>
 #include <net/iflib.h>
 
-#include "aq_device.h"
-
-#include "aq_fw.h"
+#include "aq.h"
 #include "aq_dbg.h"
 
 #define	AQ_HW_SUPPORT_SPEED(softc, s) ((softc)->link_speeds & s)
diff --git aq_ring.c aq_ring.c
index 1de52ed..cd713fe 100644
--- aq_ring.c
+++ aq_ring.c
@@ -48,12 +48,8 @@ __FBSDID("$FreeBSD$");
 #include <net/iflib.h>
 #include <netinet/in.h>
 
-#include "aq_common.h"
-
-#include "aq_ring.h"
+#include "aq.h"
 #include "aq_dbg.h"
-#include "aq_device.h"
-#include "aq_hw.h"
 #include "aq_hw_llh.h"
 
 /* iflib txrx interface prototypes */
@@ -361,7 +357,7 @@ static int aq_isc_rxd_pkt_get(void *arg, if_rxd_info_t ri)
 		ri->iri_frags[i].irf_idx = cidx;
 		ri->iri_frags[i].irf_len = len;
 
-		if ((rx_desc->wb.pkt_type & 0x60) == 1) {
+		if ((rx_desc->wb.pkt_type & 0x60) != 0) {
 			ri->iri_flags |= M_VLANTAG;
 			ri->iri_vtag = le32toh(rx_desc->wb.vlan);
 		}
diff --git aq_ring.h aq_ring.h
deleted file mode 100644
index d6ab380..0000000
--- aq_ring.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * aQuantia Corporation Network Driver
- * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   (1) Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer.
- *
- *   (2) Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following
- *   disclaimer in the documentation and/or other materials provided
- *   with the distribution.
- *
- *   (3)The name of the author may not be used to endorse or promote
- *   products derived from this software without specific prior
- *   written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _AQ_RING_H_
-#define _AQ_RING_H_
-
-#include "aq_hw.h"
-
-#define REFILL_THRESHOLD 128
-
-
-typedef volatile struct {
-    u32 rss_type:4;
-    u32 pkt_type:8;
-    u32 rdm_err:1;
-    u32 rsvd:6;
-    u32 rx_cntl:2;
-    u32 sph:1;
-    u32 hdr_len:10;
-    u32 rss_hash;
-    u16 dd:1;
-    u16 eop:1;
-    u16 rx_stat:4;
-    u16 rx_estat:6;
-    u16 rsc_cnt:4;
-    u16 pkt_len;
-    u16 next_desp;
-    u16 vlan;
-} __attribute__((__packed__)) aq_rx_wb_t;
-
-typedef volatile struct {
-    union {
-        /* HW RX descriptor */
-        struct __packed {
-            u64 buf_addr;
-            u64 hdr_addr;
-        } read;
-
-        /* HW RX descriptor writeback */
-        aq_rx_wb_t wb;
-    };
-} __attribute__((__packed__)) aq_rx_desc_t;
-
-/* Hardware tx descriptor */
-typedef volatile struct {
-    u64 buf_addr;
-
-    union {
-        struct {
-            u32 type:3;
-            u32 :1;
-            u32 len:16;
-            u32 dd:1;
-            u32 eop:1;
-            u32 cmd:8;
-            u32 :14;
-            u32 ct_idx:1;
-            u32 ct_en:1;
-            u32 pay_len:18;
-        } __attribute__((__packed__));
-        u64 flags;
-    };
-} __attribute__((__packed__)) aq_tx_desc_t;
-
-enum aq_tx_desc_type {
-    tx_desc_type_desc = 1,
-    tx_desc_type_ctx = 2,
-};
-
-enum aq_tx_desc_cmd {
-    tx_desc_cmd_vlan = 1,
-    tx_desc_cmd_fcs = 2,
-    tx_desc_cmd_ipv4 = 4,
-    tx_desc_cmd_l4cs = 8,
-    tx_desc_cmd_lso = 0x10,
-    tx_desc_cmd_wb = 0x20,
-};
-
-/* Hardware tx context descriptor */
-typedef volatile union {
-    struct __packed {
-        u64 flags1;
-        u64 flags2;
-    };
-
-    struct __packed {
-        u64 :40;
-        u32 tun_len:8;
-        u32 out_len:16;
-        u32 type:3;
-        u32 idx:1;
-        u32 vlan_tag:16;
-        u32 cmd:4;
-        u32 l2_len:7;
-        u32 l3_len:9;
-        u32 l4_len:8;
-        u32 mss_len:16;
-    };
-} __attribute__((__packed__)) aq_txc_desc_t;
-
-struct aq_ring_stats {
-	u64 rx_pkts;
-	u64 rx_bytes;
-	u64 jumbo_pkts;
-	u64 rx_err;
-	u64 irq;
-
-	u64 tx_pkts;
-	u64 tx_bytes;
-	u64 tx_drops;
-	u64 tx_queue_full;
-};
-
-struct aq_dev;
-
-struct aq_ring {
-    struct aq_dev *dev;
-    int index;
-
-    struct if_irq irq;
-    int msix;
-/* RX */
-    qidx_t rx_size;
-    int rx_max_frame_size;
-    void *rx_desc_area_ptr;
-    aq_rx_desc_t *rx_descs;
-    uint64_t rx_descs_phys;
-
-/* TX */
-    int tx_head, tx_tail;
-    qidx_t tx_size;
-    void *tx_desc_area_ptr;
-    aq_tx_desc_t *tx_descs;
-    uint64_t tx_descs_phys;
-
-    struct aq_ring_stats stats;
-};
-
-int aq_ring_rx_init(struct aq_hw *hw, struct aq_ring *ring);
-int aq_ring_tx_init(struct aq_hw *hw, struct aq_ring *ring);
-
-int aq_ring_tx_start(struct aq_hw *hw, struct aq_ring *ring);
-int aq_ring_tx_stop(struct aq_hw *hw, struct aq_ring *ring);
-int aq_ring_rx_start(struct aq_hw *hw, struct aq_ring *ring);
-int aq_ring_rx_stop(struct aq_hw *hw, struct aq_ring *ring);
-
-int aq_ring_tx_tail_update(struct aq_hw *hw, struct aq_ring *ring, u32 tail);
-
-
-extern struct if_txrx aq_txrx;
-int		aq_intr(void *arg);
-
-#endif /* _AQ_RING_H_ */
-- 
2.45.2

